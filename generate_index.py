#!/usr/bin/env python3
"""
Generate repository index for Image-To-Image-Prompts
Creates a navigable index of all prompt files organized by category
"""

import os
from pathlib import Path
from collections import defaultdict
import re


def humanize_filename(filename):
    """Convert filename to human-readable title"""
    # Remove extension
    name = Path(filename).stem
    # Replace hyphens and underscores with spaces
    name = name.replace('-', ' ').replace('_', ' ')
    # Capitalize words
    return name.title()


def humanize_category(category):
    """Convert category folder name to human-readable title"""
    # Replace hyphens and underscores with spaces
    name = category.replace('-', ' ').replace('_', ' ')
    # Capitalize words
    return name.title()


def scan_prompts_directory(base_path):
    """Scan the prompts directory and organize files by category"""
    prompts_path = Path(base_path) / 'prompts'

    if not prompts_path.exists():
        raise FileNotFoundError(f"Prompts directory not found: {prompts_path}")

    categories = defaultdict(list)

    # Walk through the prompts directory
    for category_dir in sorted(prompts_path.iterdir()):
        if category_dir.is_dir():
            category_name = category_dir.name

            # Find all markdown and text files in this category
            files = []
            for ext in ['*.md', '*.txt']:
                files.extend(category_dir.glob(ext))

            # Sort files alphabetically
            files = sorted(files, key=lambda x: x.name)

            if files:
                categories[category_name] = files

    return categories


def generate_index_content(categories, base_path):
    """Generate markdown index content"""
    lines = []
    lines.append("## Repository Index\n")
    lines.append("This index is auto-generated. Browse prompts by category:\n")

    # Generate table of contents
    lines.append("### Categories\n")
    for category in sorted(categories.keys()):
        category_title = humanize_category(category)
        # Create anchor link (GitHub style)
        anchor = category_title.lower().replace(' ', '-')
        lines.append(f"- [{category_title}](#{anchor})")
    lines.append("")

    # Generate detailed sections
    lines.append("---\n")

    for category in sorted(categories.keys()):
        category_title = humanize_category(category)
        files = categories[category]

        lines.append(f"### {category_title}\n")

        # List all files in this category
        for file_path in files:
            file_title = humanize_filename(file_path.name)
            # Create relative path from repository root
            relative_path = file_path.relative_to(base_path)
            # Convert to URL-friendly path
            github_path = str(relative_path).replace('\\', '/')
            lines.append(f"- [{file_title}]({github_path})")

        lines.append("")

    # Add metadata footer
    lines.append("---\n")
    lines.append("*This index is automatically generated by `generate_index.py`*")

    return '\n'.join(lines)


def write_index_file(content, output_path):
    """Write the generated index to a file"""
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write(content)
    print(f"âœ“ Index written to: {output_path}")


def inject_into_readme(index_content, readme_path):
    """Inject index content into README.md between markers"""

    start_marker = "<!-- INDEX_START -->"
    end_marker = "<!-- INDEX_END -->"

    # Read existing README
    if readme_path.exists():
        with open(readme_path, 'r', encoding='utf-8') as f:
            readme_content = f.read()
    else:
        raise FileNotFoundError(f"README.md not found: {readme_path}")

    # Check if markers exist
    if start_marker not in readme_content or end_marker not in readme_content:
        print(f"âš  Markers not found in README.md")
        print(f"Please add these markers where you want the index:")
        print(f"  {start_marker}")
        print(f"  {end_marker}")
        return False

    # Find marker positions
    start_pos = readme_content.find(start_marker) + len(start_marker)
    end_pos = readme_content.find(end_marker)

    # Construct new README content
    new_content = (
        readme_content[:start_pos] +
        "\n" + index_content + "\n" +
        readme_content[end_pos:]
    )

    # Write updated README
    with open(readme_path, 'w', encoding='utf-8') as f:
        f.write(new_content)

    print(f"âœ“ Index injected into README.md")
    return True


def main():
    """Main execution function"""
    # Get repository root (script location)
    script_dir = Path(__file__).parent

    print("ðŸ“š Generating repository index...")

    # Scan prompts directory
    categories = scan_prompts_directory(script_dir)

    if not categories:
        print("âš  No prompt files found!")
        return

    print(f"âœ“ Found {len(categories)} categories with {sum(len(files) for files in categories.values())} files")

    # Generate index content
    index_content = generate_index_content(categories, script_dir)

    # Write standalone index file
    index_file = script_dir / 'REPOSITORY_INDEX.md'
    write_index_file(index_content, index_file)

    # Inject into README
    readme_file = script_dir / 'README.md'
    inject_into_readme(index_content, readme_file)

    print("âœ… Repository index generation complete!")


if __name__ == '__main__':
    main()
